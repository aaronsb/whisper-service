#!/usr/bin/env bash

# Colors and styling
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Nerd Font icons
ICON_MIC="󰍬"
ICON_WAVE="󰝚"
ICON_CHECK="󰄬"
ICON_ERROR="󰅚"
ICON_LOADING="󰔟"
ICON_SERVER="󰒋"
ICON_SOUND="󰓃"
ICON_VIDEO="󰕧"
ICON_YOUTUBE="󰗃"
ICON_CONVERT="󰁕"
ICON_INFO="󰋼"
ICON_SAVE="󰆓"

# Initialize variables
DEBUG=false
VERBOSE=false
FILE=""
MODE="audio"  # Default mode
KEEP=false
JSONOUT=false

# Check for ffmpeg and yt-dlp
FFMPEG_PRESENT=false
YTDLP_PRESENT=false
if command -v ffmpeg >/dev/null 2>&1; then
    FFMPEG_PRESENT=true
fi
if command -v yt-dlp >/dev/null 2>&1; then
    YTDLP_PRESENT=true
fi

# Function to show usage (updated)
show_usage() {
    echo -e "${BOLD}Usage:${NC}"
    echo -e "  whisper [options] <file>"
    echo -e "  whisper [options] --audio <file>"
    if [ "$FFMPEG_PRESENT" = true ]; then
        echo -e "  whisper [options] --video <video_file>"
    else
        echo -e "${YELLOW}${ICON_INFO} ffmpeg not found. Install ffmpeg to enable video processing.${NC}"
    fi
    if [ "$FFMPEG_PRESENT" = true ] && [ "$YTDLP_PRESENT" = true ]; then
        echo -e "  whisper [options] --youtube <youtube_url>"
    else
        echo -e "${YELLOW}${ICON_INFO} yt-dlp or ffmpeg not found. Install both to enable YouTube processing.${NC}"
    fi
    echo
    echo -e "${BOLD}Options:${NC}"
    echo -e "  -h, --help     Show this help message"
    echo -e "  -v, --verbose  Show detailed output including segments"
    echo -e "  --debug        Enable debug logging"
    echo -e "  --audio        Explicitly specify audio file input"
    if [ "$FFMPEG_PRESENT" = true ]; then
        echo -e "  --video        Specify video file input (mp4, mov, mkv, avi, webm, ts)"
    fi
    if [ "$FFMPEG_PRESENT" = true ] && [ "$YTDLP_PRESENT" = true ]; then
        echo -e "  --youtube      Specify YouTube video URL for transcription"
    fi
    echo -e "  --keep         Keep all processed media files"
    echo -e "  --jsonout      Output only the JSON transcription payload to stdout"
    echo
    echo -e "${BOLD}Examples:${NC}"
    echo -e "  whisper audio.mp3"
    echo -e "  whisper --audio audio.mp3"
    echo -e "  whisper recording.wav --verbose"
    echo -e "  whisper --video clip.mp4"
    echo -e "  whisper --youtube https://youtu.be/dQw4w9WgXcQ"
    echo -e "  whisper --keep --video clip.mp4"
    echo -e "  whisper --jsonout audio.mp3"
}

# Function to log debug information
debug_log() {
    if [ "$DEBUG" = true ]; then
        echo -e "${CYAN}[DEBUG] $1${NC}" >&2
    fi
}

# Function to check if service is running
check_service() {
    debug_log "Checking service health..."
    local health_response
    health_response=$(curl -s "http://localhost:8000/health")

    if [ $? -ne 0 ]; then
        echo -e "${RED}${ICON_ERROR} Error: Whisper service is not running${NC}"
        echo -e "${BLUE}${ICON_SERVER} Start the service with:${NC} docker compose up -d"
        return 1
    fi

    debug_log "Service is healthy"
    return 0
}

# Function to check if file is supported audio format
check_audio_format() {
    local file="$1"
    local ext="${file##*.}"
    ext="${ext,,}"  # Convert to lowercase

    local valid_extensions=("mp3" "wav" "m4a" "ogg" "flac")
    if [[ " ${valid_extensions[*]} " =~ " ${ext} " ]]; then
        debug_log "File format '$ext' is supported"
        return 0
    else
        echo -e "${RED}${ICON_ERROR} Error: Unsupported audio format '$ext'${NC}"
        echo -e "Supported formats: ${valid_extensions[*]}"
        return 1
    fi
}

# Function to check if file is supported video format
check_video_format() {
    local file="$1"
    local ext="${file##*.}"
    ext="${ext,,}"  # Convert to lowercase

    local valid_extensions=("mp4" "mov" "mkv" "avi" "webm" "ts")
    if [[ " ${valid_extensions[*]} " =~ " ${ext} " ]]; then
        debug_log "Video format '$ext' is supported"
        return 0
    else
        echo -e "${RED}${ICON_ERROR} Error: Unsupported video format '$ext'${NC}"
        echo -e "Supported formats: ${valid_extensions[*]}"
        return 1
    fi
}

# Function to show spinner while waiting for processing
spinner() {
    local pid=$1
    local message="${2:-Processing...}"
    local delay=0.1
    local spinstr='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " %s %s" "${spinstr}" "${message}"  # Removed ANSI codes here
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\r"
    done
    printf "\r%*s\r" "$(tput cols)" ""  # Clear the entire line
}

# Function to save JSON response
save_json_response() {
    local response="$1"
    local input_file="$2"

    # Create output filename from input filename
    local base_name="$(basename "${input_file%.*}")"
    local output_file="${base_name}.json"

    # Format JSON for better readability
    echo "$response" | jq '.' > "$output_file"

    if [ $? -eq 0 ]; then
        printf "${GREEN}${ICON_SAVE} Saved transcript to:${NC} %s\n" "$output_file"
        return 0
    else
        printf "${RED}${ICON_ERROR} Failed to save transcript${NC}\n"
        return 1
    fi
}

# Function to process JSON response
process_json_response() {
    local response="$1"
    local text

    # Try to extract text from response
    text=$(echo "$response" | jq -r '.text' 2>/dev/null)
    if [ $? -ne 0 ] || [ "$text" = "null" ] || [ -z "$text" ]; then
        debug_log "Failed to extract text from response"
        return 1
    fi

    # Only print transcript if not in JSON output mode and verbose mode
    if [ "$JSONOUT" = false ] && [ "$VERBOSE" = true ]; then
        echo -e "\n${BOLD}Transcription:${NC}"
        echo -e "$text\n"

        echo -e "${BOLD}Segments:${NC}"
        echo "$response" | jq -r '.segments[] | "\(.start)s -> \(.end)s: \(.text)"' 2>/dev/null
        echo
    elif [ "$JSONOUT" = true ]; then
        # In JSON output mode, output the JSON response
        echo "$response"
    fi

    return 0
}

# Function to send file to whisper service
send_to_whisper() {
    local file="$1"
    debug_log "Sending file to whisper service: $file"

    if [ "$JSONOUT" = false ]; then
        printf "${YELLOW}${ICON_LOADING} Sending file to Whisper service...${NC}\n"
    fi

    # Use a temporary file for the response
    local temp_response
    temp_response=$(mktemp)

    # Send the request and capture the response
    curl -s -X POST \
         -F "file=@$file" \
         --max-time 3600 \
         "http://localhost:8000/transcribe/" > "$temp_response" &

    local curl_pid=$!
    if [ "$JSONOUT" = false ]; then
        spinner $curl_pid "Transcribing..."
    fi
    wait $curl_pid
    local curl_status=$?

    if [ $curl_status -ne 0 ]; then
        echo -e "${RED}${ICON_ERROR} Error: Failed to connect to service${NC}"
        rm -f "$temp_response"
        return 1
    fi

    # Read response
    local response
    response=$(cat "$temp_response")
    rm -f "$temp_response"

    debug_log "Received response from service"

    # Check if response is empty
    if [ -z "$response" ]; then
        echo -e "${RED}${ICON_ERROR} Error: Empty response from service${NC}"
        return 1
    fi

    # Validate JSON
    if ! echo "$response" | jq . >/dev/null 2>&1; then
        echo -e "${RED}${ICON_ERROR} Error: Invalid JSON response${NC}"
        debug_log "Response was: $response"
        return 1
    fi

    # Save JSON response
    save_json_response "$response" "$file"

    # Process and display transcription
    process_json_response "$response"
    return $?
}

# Function to extract audio from video
extract_audio() {
    local video_file="$1"
    local audio_file="$2"

    if [ "$JSONOUT" = false ]; then
        printf "${YELLOW}${ICON_CONVERT} Extracting audio from video...${NC}\n"
    fi

    ffmpeg -loglevel error -y -i "$video_file" -vn -acodec libmp3lame "$audio_file" &
    local ffmpeg_pid=$!
    spinner $ffmpeg_pid "Putting ffmpeg to work..."
    wait $ffmpeg_pid
    if [ $? -ne 0 ]; then
        echo -e "${RED}${ICON_ERROR} Error: Failed to extract audio${NC}"
        return 1
    fi
    return 0
}

# Function to download YouTube video
download_youtube_video() {
    local url="$1"
    local output_file="$2"

    if [ "$JSONOUT" = false ]; then
        printf "${YELLOW}${ICON_LOADING} Downloading video from YouTube...${NC}\n"
    fi

    yt-dlp -q -f best -o "$output_file" "$url"
    if [ $? -ne 0 ]; then
        echo -e "${RED}${ICON_ERROR} Error: Failed to download YouTube video${NC}"
        return 1
    fi
    return 0
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_usage
            exit 0
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        --debug)
            DEBUG=true
            shift
            ;;
        --keep)
            KEEP=true
            shift
            ;;
        --jsonout)
            JSONOUT=true
            shift
            ;;
        --audio)
            MODE="audio"
            shift
            if [ -n "$1" ] && [ -f "$1" ]; then
                FILE="$1"
                shift
            else
                echo -e "${RED}${ICON_ERROR} Error: Missing or invalid file after --audio${NC}"
                exit 1
            fi
            ;;
        --video)
            if [ "$FFMPEG_PRESENT" = false ]; then
                echo -e "${RED}${ICON_ERROR} Error: ffmpeg is not installed. Install ffmpeg to use --video${NC}"
                exit 1
            fi
            MODE="video"
            shift
            if [ -n "$1" ] && [ -f "$1" ]; then
                FILE="$1"
                shift
            else
                echo -e "${RED}${ICON_ERROR} Error: Missing or invalid file after --video${NC}"
                exit 1
            fi
            ;;
        --youtube)
            if [ "$FFMPEG_PRESENT" = false ] || [ "$YTDLP_PRESENT" = false ]; then
                echo -e "${RED}${ICON_ERROR} Error: ffmpeg and yt-dlp are required for --youtube${NC}"
                exit 1
            fi
            MODE="youtube"
            shift
            if [ -n "$1" ]; then
                FILE="$1"
                shift
            else
                echo -e "${RED}${ICON_ERROR} Error: Missing URL after --youtube${NC}"
                exit 1
            fi
            ;;
        *)
            if [ -z "$FILE" ]; then
                if [ -f "$1" ]; then
                    FILE="$1"
                    MODE="audio"
                else
                    echo -e "${RED}${ICON_ERROR} Error: File not found: $1${NC}"
                    exit 1
                fi
            else
                echo -e "${RED}${ICON_ERROR} Error: Too many arguments${NC}"
                show_usage
                exit 1
            fi
            shift
            ;;
    esac
done

# Check if a file was provided
if [ -z "$FILE" ]; then
    show_usage
    exit 1
fi

# Main execution
if [ "$JSONOUT" = false ]; then
    echo -e "\n${BLUE}${ICON_SOUND} Whisper Transcription${NC}"
fi

# Check service health
check_service || exit 1

# Create a temporary working directory
WORKDIR=$(mktemp -d)
debug_log "Created temporary directory: $WORKDIR"

# Initialize variables for cleanup
FILES_TO_CLEAN=()

# Function to clean up temporary files
cleanup() {
    if [ "$KEEP" = false ]; then
        debug_log "Cleaning up temporary files"
        rm -rf "$WORKDIR"
    else
        debug_log "Keeping temporary files"
        # Move files to current directory
        for file in "${FILES_TO_CLEAN[@]}"; do
            mv "$file" .
        done
        rm -rf "$WORKDIR"
        if [ "$JSONOUT" = false ]; then
            echo -e "\nFiles retained after processing:"
            ls -1 "${FILES_TO_CLEAN[@]/#/.\/}" 2>/dev/null
        fi
    fi
}

trap cleanup EXIT

case "$MODE" in
    audio)
        # Check if file exists and is readable
        if [ ! -r "$FILE" ]; then
            echo -e "${RED}${ICON_ERROR} Error: Cannot read file: $FILE${NC}"
            exit 1
        fi

        # Check audio format
        check_audio_format "$FILE" || exit 1

        # Copy audio file to working directory
        AUDIO_FILE="$WORKDIR/$(basename "$FILE")"
        cp "$FILE" "$AUDIO_FILE"
        FILES_TO_CLEAN+=("$AUDIO_FILE")

        if [ "$JSONOUT" = false ]; then
            echo -e "${BLUE}${ICON_WAVE} Audio file:${NC} $(basename "$FILE")"
        fi
        ;;
    video)
        # Check if file exists and is readable
        if [ ! -r "$FILE" ]; then
            echo -e "${RED}${ICON_ERROR} Error: Cannot read file: $FILE${NC}"
            exit 1
        fi

        # Check video format
        check_video_format "$FILE" || exit 1

        # Copy video file to working directory
        VIDEO_FILE="$WORKDIR/$(basename "$FILE")"
        cp "$FILE" "$VIDEO_FILE"
        FILES_TO_CLEAN+=("$VIDEO_FILE")

        # Extract audio
        AUDIO_FILE="$WORKDIR/$(basename "${FILE%.*}").mp3"
        extract_audio "$VIDEO_FILE" "$AUDIO_FILE" || exit 1
        FILES_TO_CLEAN+=("$AUDIO_FILE")

        if [ "$JSONOUT" = false ]; then
            echo -e "${BLUE}${ICON_VIDEO} Video file:${NC} $(basename "$FILE")"
            echo -e "${BLUE}${ICON_WAVE} Extracted audio file:${NC} $(basename "$AUDIO_FILE")"
        fi
        ;;
    youtube)
        # Download YouTube video
        VIDEO_FILE="$WORKDIR/video.mp4"
        download_youtube_video "$FILE" "$VIDEO_FILE" || exit 1
        FILES_TO_CLEAN+=("$VIDEO_FILE")

        # Extract audio
        AUDIO_FILE="$WORKDIR/audio.mp3"
        extract_audio "$VIDEO_FILE" "$AUDIO_FILE" || exit 1
        FILES_TO_CLEAN+=("$AUDIO_FILE")

        if [ "$JSONOUT" = false ]; then
            echo -e "${BLUE}${ICON_YOUTUBE} YouTube URL:${NC} $FILE"
            echo -e "${BLUE}${ICON_WAVE} Extracted audio file:${NC} $(basename "$AUDIO_FILE")"
        fi
        ;;
esac

# Send to whisper and process response
if send_to_whisper "$AUDIO_FILE"; then
    if [ "$JSONOUT" = false ]; then
        echo -e "${GREEN}${ICON_CHECK} Transcription complete!${NC}"
    fi
    exit 0
else
    exit 1
fi
